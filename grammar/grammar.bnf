{
  parserClass="org.jetbrains.agda.gen.parser.AgdaParser"
  stubParserClass="org.jetbrains.agda.parser.AgdaParserUtil"
  elementTypeHolderClass="org.jetbrains.agda.gen.parser.AgdaTokenTypes"
  tokenTypeClass="org.jetbrains.agda.parser.AgdaToken"
  elementTypeClass="org.jetbrains.agda.parser.AgdaCompositeElementType"

  tokens = [
    LET_KEYWORD="let"
    IN_KEYWORD="in"
    DATA_KEYWORD="data"
    WHERE_KEYWORD="where"
    MODULE_KEYWORD="module"
    FORALL="forall"
    OPEN_KEYWORD="open"
    IMPORT_KEYWORD="import"

    SPEC_CHARACTERS="SPEC_CHARACTERS"
    STRING="STRING"
    COMMENT="COMMENT"
    END_OF_LINE_COMMENT="--"
    DOT="."
    COLON=":"
    ASSIGNMENT="="
    SEMICOLON=";"
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_PAREN="("
    RIGHT_PAREN=")"
    ARROW="->"

    LAMBDA="\\"
    VIRTUAL_LEFT_PAREN="VIRTUAL_LEFT_PAREN"
    VIRTUAL_RIGHT_PAREN="VIRTUAL_RIGHT_PAREN"
    VIRTUAL_SEMICOLON="VIRTUAL_SEMICOLON"
  ]

  psiPackage="org.jetbrains.agda.psi"
  psiImplPackage="org.jetbrains.agda.psi.impl"
}

root ::= declaration *

private recover ::= ! (id | "data" | VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON)

fqName ::= id ('.' id) *

name_declaration ::= id

private declaration ::= module_declaration | module_import | data_declaration |
        function_type_declaration | function_declaration | absurd_function | VIRTUAL_SEMICOLON | VIRTUAL_RIGHT_PAREN {recoverUntil=recover}

module_declaration ::= 'module' fqName bindings "where" {pin=1}

private bindings ::= binding *

new_line ::= VIRTUAL_LEFT_PAREN | VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON | ()


private ids ::= name_declaration+

binding ::= (new_line "{" ids (":" expression)? "}") | (new_line "(" ids (":" expression)? ")")

private import_names ::= fqName (';' fqName) *

module_import ::= 'open' ? 'import' fqName as_name? using_or_hiding? renaming? {pin=2}

private as_name ::= "as" id

renaming ::= new_line "renaming" "(" renamings ")"

private renamings ::= id "to" id (new_line ";" id "to" id)*

using_or_hiding ::= ('using' '(' import_names ')') | ('hiding' '(' import_names ')')

// Data declaration

data_declaration ::= "data" name_declaration bindings ":" expression "where" (VIRTUAL_LEFT_PAREN constructors VIRTUAL_RIGHT_PAREN) ? {pin=1}

constructors ::= type_signature (VIRTUAL_SEMICOLON type_signature) *

// Function declaration

function_type_declaration ::= name_declaration ":" expression {pin=2}

function_declaration ::= expression "=" expression {pin = 2}

absurd_function ::= expression VIRTUAL_SEMICOLON {pin = 2}

// Expressions

a_name ::= id {mixin = "org.jetbrains.agda.psi.AgdaReferenceElementImpl"}

absurd_expression ::= "(" ")" {extends=expression}

parenthesis_expression ::= "(" expression ")" {pin=1; extends=expression}

private atom_expr ::= absurd_expression | parenthesis_expression | "{" "!!" "}" | "." | a_name

application ::= (atom_expr maybe_application)

private maybe_application ::= application | atom_expr

expression ::= let_expression | tele_arrow | lambda_expression | maybe_function_type | forall_expression

let_expression ::= "let" name_declaration "=" expression "in" new_line expression

typed_untyped_binding ::= '{' ids '}' | ("{" type_signature "}") | ("(" type_signature ")")

forall_expression ::= 'forall' typed_untyped_binding+ ARROW expression

tele_arrow ::= telescope+ ARROW expression
telescope ::= implicit_telescope | explicit_telescope
implicit_telescope ::= "{" type_signature "}" {extends=telescope}
explicit_telescope ::= "(" type_signature ")" {extends=telescope}

type_signature ::= ids ":" expression

lambda_expression ::= "\\" (("(" type_signature ")" ) | ids) ARROW expression {extends=expression}

function_type ::= maybe_application ARROW maybe_function_type
private maybe_function_type ::= function_type | maybe_application
