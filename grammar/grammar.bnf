{
  parserClass="org.jetbrains.agda.gen.parser.AgdaParser"
  stubParserClass="org.jetbrains.agda.parser.AgdaParserUtil"
  elementTypeHolderClass="org.jetbrains.agda.gen.parser.AgdaTokenTypes"
  tokenTypeClass="org.jetbrains.agda.parser.AgdaToken"
  elementTypeClass="org.jetbrains.agda.parser.AgdaCompositeElementType"

  tokens = [
    KEYWORD="KEYWORD"
    DATA_KEYWORD="data"
    WHERE_KEYWORD="where"
    SPEC_CHARACTERS="SPEC_CHARACTERS"
    STRING="STRING"
    COMMENT="COMMENT"
    END_OF_LINE_COMMENT="--"
    DOT="."
    COLON=":"
    ASSIGNMENT="="
    SEMICOLON=";"
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_PAREN="("
    RIGHT_PAREN=")"
    ARROW="->"
    VIRTUAL_LEFT_PAREN="VIRTUAL_LEFT_PAREN"
    VIRTUAL_RIGHT_PAREN="VIRTUAL_RIGHT_PAREN"
    VIRTUAL_SEMICOLON="VIRTUAL_SEMICOLON"
  ]

  psiPackage="org.jetbrains.agda.psi"
  psiImplPackage="org.jetbrains.agda.psi.impl"
}

root ::= declaration *

fqName ::= id ('.' id) *

private declaration ::= module_declaration | module_import | data_declaration |
      function_type_declaration | function_declaration | expression | VIRTUAL_SEMICOLON | VIRTUAL_RIGHT_PAREN

module_declaration ::= 'module' fqName bindings "where" {pin=1}

private bindings ::= binding *

new_line ::= VIRTUAL_LEFT_PAREN | VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON | ()

ids ::= id+

binding ::= (new_line "{" ids (":" expression)? "}") | (new_line "(" ids (":" expression)? ")")

import_names ::= fqName (';' fqName) *

module_import ::= 'open' ? 'import' fqName as_name? using_or_hiding? renaming? {pin=2}

as_name ::= "as" id

renaming ::= new_line "renaming" "(" renamings ")"

private renamings ::= id "to" id (new_line ";" id "to" id)*

using_or_hiding ::= ('using' '(' import_names ')') | ('hiding' '(' import_names ')')

data_declaration ::= "data" id bindings ":" expression "where" (VIRTUAL_LEFT_PAREN constructors VIRTUAL_RIGHT_PAREN) ? {pin=1}

constructors ::= constructor (VIRTUAL_SEMICOLON constructor) *
constructor ::= expression ":" expression {pin=2 recoverUntil = recover}

private recover ::= ! (VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON)

function_type_declaration ::= expression ":" expression {pin=2}

function_declaration ::= expression "=" expression {pin=2}



private atom_expr ::= ("(" expression ")") | ("(" ")") | "{" "!!" "}" | "." | id

application ::= (atom_expr application) | atom_expr
expression ::= tele_arrow | lambda_expression | function_type


tele_arrow ::= telescope ARROW expression
telescope ::= ("{" ids ":" expression "}") | ("(" ids ":" expression ")")

lambda_expression ::= "\\" "(" id ":" expression ")" ARROW expression

function_type ::= application (ARROW function_type)?
