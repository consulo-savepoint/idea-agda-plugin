{
  parserClass="org.jetbrains.agda.gen.parser.AgdaParser"
  stubParserClass="org.jetbrains.agda.parser.AgdaParserUtil"
  elementTypeHolderClass="org.jetbrains.agda.gen.parser.AgdaTokenTypes"
  tokenTypeClass="org.jetbrains.agda.parser.AgdaToken"
  elementTypeClass="org.jetbrains.agda.parser.AgdaCompositeElementType"

  tokens = [
    LET_KEYWORD="let"
    IN_KEYWORD="in"
    DATA_KEYWORD="data"
    WHERE_KEYWORD="where"
    MODULE_KEYWORD="module"
    RECORD_KEYWORD="record"
    POSTULATE_KEYWORD="postulate"
    INFIX_KEYWORD="infix"
    INFIXL_KEYWORD="infixl"
    INFIXR_KEYWORD="infixr"
    FORALL="forall"
    OPEN_KEYWORD="open"
    IMPORT_KEYWORD="import"
    CONSTRUCTOR_KEYWORD="constructor"
    FIELD_KEYWORD="field"
    PUBLIC_KEYWORD="public"
    USING_KEYWORD="using"
    HIDING_KEYWORD="hiding"
    MUTUAL_KEYWORD="mutual"

    NUMBER="number"
    SPEC_CHARACTERS="SPEC_CHARACTERS"
    STRING="STRING"
    COMMENT="COMMENT"
    END_OF_LINE_COMMENT="--"
    DOT="."
    COLON=":"
    ASSIGNMENT="="
    SEMICOLON=";"
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_PAREN="("
    RIGHT_PAREN=")"
    ARROW="->"
    PRAGMA_OPEN= "{-#"
    PRAGMA_CLOSE="#-}"

    LAMBDA="\\"
    VIRTUAL_LEFT_PAREN="VIRTUAL_LEFT_PAREN"
    VIRTUAL_RIGHT_PAREN="VIRTUAL_RIGHT_PAREN"
    VIRTUAL_SEMICOLON="VIRTUAL_SEMICOLON"
  ]

  psiPackage="org.jetbrains.agda.psi"
  psiImplPackage="org.jetbrains.agda.psi.impl"
}

root ::= declaration *

private recover ::= ! (VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON)

private maybe_newLine ::= (VIRTUAL_LEFT_PAREN | VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON)?

fqName ::= id ('.' id) * {mixin = "org.jetbrains.agda.psi.AgdaReferenceElementImpl"}

name_declaration ::= id {mixin = "org.jetbrains.agda.psi.AgdaNamedElement"}

private recovering_declaration ::= module_declaration | module_import | open | infix | postulate | pragma | mutual | function_type_declaration | function_declaration | absurd_function {recoverUntil=recover}

private declaration ::= VIRTUAL_SEMICOLON | data_declaration | record_declaration | record_field | record_constructor | recovering_declaration

mutual ::= MUTUAL_KEYWORD VIRTUAL_LEFT_PAREN (declaration +) VIRTUAL_RIGHT_PAREN

open ::= 'open' fqName module_arguments as_name? "public"? using_or_hiding? renaming? {pin=1}

module_import ::= 'open' ? 'import' fqName module_arguments as_name? "public"? using_or_hiding? renaming?  {pin=2}

module_arguments ::= expression *

record_declaration ::= "record" name_declaration typed_untyped_bindings ":" expression "where" VIRTUAL_LEFT_PAREN (declaration +) VIRTUAL_RIGHT_PAREN {pin=1}

type_signatures ::= type_signature (VIRTUAL_SEMICOLON type_signature)*

record_field ::= "field" ((VIRTUAL_LEFT_PAREN type_signatures VIRTUAL_RIGHT_PAREN) | type_signature) {pin=1}
record_constructor ::= "constructor" maybe_newLine name_declaration {pin=1}

pragma_string ::= (id | "(" | ")" | "\\" | "->") *

pragma ::= PRAGMA_OPEN (build_in_pragma | compiled_type_pragma | compiled_pragma) PRAGMA_CLOSE {pin=1}

build_in_pragma ::= "BUILTIN" name_declaration name_declaration {pin=1}
compiled_type_pragma ::= "COMPILED_TYPE" name_declaration pragma_string {pin=1}
compiled_pragma ::= "COMPILED" name_declaration pragma_string {pin=1}

infix ::= ("infix" | "infixl" | "infixr") NUMBER name_declaration * {pin=1}

postulate_bindings ::= type_signature (VIRTUAL_SEMICOLON type_signature) *

postulate ::= "postulate" (VIRTUAL_LEFT_PAREN postulate_bindings VIRTUAL_RIGHT_PAREN)

module_declaration ::= 'module' fqName bindings "where" (VIRTUAL_LEFT_PAREN declaration+ VIRTUAL_RIGHT_PAREN)? {pin=1}

bindings ::= binding *

new_line ::= VIRTUAL_LEFT_PAREN | VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON | ()


private ids ::= name_declaration+

binding ::= (new_line "{" ids (":" expression)? "}") | (new_line "(" ids (":" expression)? ")")

import_name ::= ("module"? fqName)

private import_names ::= import_name (";" import_name) *



as_name ::= "as" id

renaming ::= new_line "renaming" "(" renamings ")"

private renamings ::= id "to" id (new_line ";" id "to" id)*

private using_keyword ::= maybe_newLine 'using' maybe_newLine

using_or_hiding ::= (using_keyword '(' import_names ')') | ('hiding' '(' import_names ')')

// Data declaration

data_declaration ::= "data" name_declaration bindings ":" expression "where" (VIRTUAL_LEFT_PAREN constructors VIRTUAL_RIGHT_PAREN) ? {pin=1}

constructors ::= type_signature (VIRTUAL_SEMICOLON type_signature) *

// Function declaration

function_type_declaration ::= name_declaration ":" maybe_newLine expression {pin=2}

lhs ::= ("..." "|" expression) | expression

function_declaration ::= lhs "=" where_epression {pin = 2}

absurd_function ::= expression

// Expressions

absurd_expression ::= "(" ")" {extends=expression}

parenthesis_expression ::= "(" expression ")" {pin=1; extends=expression}

goal_expression ::= "{" "!!" "}"

private atom_expr ::= absurd_expression | parenthesis_expression | goal_expression | substitute_implisit | fqName | number_expression

application ::= (atom_expr maybe_application) {extends=expression}

private maybe_application ::= application | atom_expr

expression ::= let_expression | tele_arrow | lambda_expression | function_type | application | atom_expr | forall_expression

where_part ::= "where" ((VIRTUAL_LEFT_PAREN (declaration +) VIRTUAL_RIGHT_PAREN) | declaration)

where_epression ::= expression where_part?

number_expression ::= number

substitute_implisit ::= "{" (name_declaration "=")?  expression "}"

let_expression ::= "let" name_declaration "=" expression "in" new_line expression

typed_untyped_binding ::= name_declaration+  | '{' ids '}' | ("{" type_signature "}") | ("(" type_signature ")")

private typed_untyped_bindings ::= (typed_untyped_binding maybe_newLine)*

forall_expression ::= 'forall' typed_untyped_bindings ARROW maybe_newLine expression {pin=1}

tele_arrow ::= telescope+ ARROW maybe_newLine expression
telescope ::= implicit_telescope | explicit_telescope
implicit_telescope ::= "{" type_signature "}" {extends=telescope}
explicit_telescope ::= "(" type_signature ")" {extends=telescope}

type_signature ::= ids ":" expression

lambda_expression ::= ("\\" | "Î»") (("(" ids ":" expression ")") | ids) ARROW expression {extends=expression}

function_type ::= maybe_application ARROW maybe_newLine expression
