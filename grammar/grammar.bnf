{
  parserClass="org.jetbrains.agda.gen.parser.AgdaParser"
  stubParserClass="org.jetbrains.agda.parser.AgdaParserUtil"
  elementTypeHolderClass="org.jetbrains.agda.gen.parser.AgdaTokenTypes"
  tokenTypeClass="org.jetbrains.agda.parser.AgdaToken"
  elementTypeClass="org.jetbrains.agda.parser.AgdaCompositeElementType"

  tokens = [
    LET_KEYWORD="let"
    IN_KEYWORD="in"
    DATA_KEYWORD="data"
    WHERE_KEYWORD="where"
    MODULE_KEYWORD="module"
    RECORD_KEYWORD="record"
    POSTULATE_KEYWORD="postulate"
    INFIXL_KEYWORD="infixl"
    INFIXR_KEYWORD="infixr"
    FORALL="forall"
    OPEN_KEYWORD="open"
    IMPORT_KEYWORD="import"

    NUMBER="number"
    SPEC_CHARACTERS="SPEC_CHARACTERS"
    STRING="STRING"
    COMMENT="COMMENT"
    END_OF_LINE_COMMENT="--"
    DOT="."
    COLON=":"
    ASSIGNMENT="="
    SEMICOLON=";"
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_PAREN="("
    RIGHT_PAREN=")"
    ARROW="->"
    PRAGMA_OPEN= "{-#"
    PRAGMA_CLOSE="#-}"

    LAMBDA="\\"
    VIRTUAL_LEFT_PAREN="VIRTUAL_LEFT_PAREN"
    VIRTUAL_RIGHT_PAREN="VIRTUAL_RIGHT_PAREN"
    VIRTUAL_SEMICOLON="VIRTUAL_SEMICOLON"
  ]

  psiPackage="org.jetbrains.agda.psi"
  psiImplPackage="org.jetbrains.agda.psi.impl"
}

root ::= declaration *

private recover ::= ! (VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON)

fqName ::= id ('.' id) *

name_declaration ::= id

private recovering_declaration ::= module_declaration | module_import | infix | postulate | pragma | function_type_declaration | function_declaration | absurd_function  {recoverUntil=recover}

private declaration ::= VIRTUAL_SEMICOLON | VIRTUAL_RIGHT_PAREN | data_declaration | record_declaration | recovering_declaration

record_declaration ::= "record" name_declaration bindings ":" expression "where" (VIRTUAL_LEFT_PAREN record_elements VIRTUAL_RIGHT_PAREN) ? {pin=1}

private record_elements ::= record_element (VIRTUAL_SEMICOLON record_element) *

private record_element ::= record_constructor | record_field

record_field ::= "field" type_signature {pin=1}
record_constructor ::= "constructor" name_declaration {pin=1}

pragma ::= PRAGMA_OPEN (id | "(" | ")" | "\\")* PRAGMA_CLOSE {pin=1}

infix ::= ("infixl" | "infixr") NUMBER name_declaration {pin=1}

postulate_bindings ::= type_signature (VIRTUAL_SEMICOLON type_signature) *

postulate ::= "postulate" (VIRTUAL_LEFT_PAREN postulate_bindings VIRTUAL_RIGHT_PAREN)

module_declaration ::= 'module' fqName bindings "where" {pin=1}

private bindings ::= binding *

new_line ::= VIRTUAL_LEFT_PAREN | VIRTUAL_RIGHT_PAREN | VIRTUAL_SEMICOLON | ()


private ids ::= name_declaration+

binding ::= (new_line "{" ids (":" expression)? "}") | (new_line "(" ids (":" expression)? ")")

private import_names ::= fqName (';' fqName) *

module_import ::= 'open' ? 'import' fqName as_name? using_or_hiding? renaming? {pin=2}

private as_name ::= "as" id

renaming ::= new_line "renaming" "(" renamings ")"

private renamings ::= id "to" id (new_line ";" id "to" id)*

using_or_hiding ::= ('using' '(' import_names ')') | ('hiding' '(' import_names ')')

// Data declaration

data_declaration ::= "data" name_declaration bindings ":" expression "where" (VIRTUAL_LEFT_PAREN constructors VIRTUAL_RIGHT_PAREN) ? {pin=1}

constructors ::= type_signature (VIRTUAL_SEMICOLON type_signature) *

// Function declaration

function_type_declaration ::= name_declaration ":" expression {pin=2}

function_declaration ::= expression "=" expression {pin = 2}

absurd_function ::= expression VIRTUAL_SEMICOLON {pin = 2}

// Expressions

a_name ::= id {mixin = "org.jetbrains.agda.psi.AgdaReferenceElementImpl"}

absurd_expression ::= "(" ")" {extends=expression}

parenthesis_expression ::= "(" expression ")" {pin=1; extends=expression}

private atom_expr ::= absurd_expression | parenthesis_expression | "{" "!!" "}" | "." | a_name

application ::= (atom_expr maybe_application)

private maybe_application ::= application | atom_expr

expression ::= let_expression | tele_arrow | lambda_expression | maybe_function_type | forall_expression

let_expression ::= "let" name_declaration "=" expression "in" new_line expression

typed_untyped_binding ::= '{' ids '}' | ("{" type_signature "}") | ("(" type_signature ")")

forall_expression ::= 'forall' typed_untyped_binding+ ARROW expression

tele_arrow ::= telescope+ ARROW expression
telescope ::= implicit_telescope | explicit_telescope
implicit_telescope ::= "{" type_signature "}" {extends=telescope}
explicit_telescope ::= "(" type_signature ")" {extends=telescope}

type_signature ::= ids ":" expression

lambda_expression ::= "\\" (("(" type_signature ")" ) | ids) ARROW expression {extends=expression}

function_type ::= maybe_application ARROW maybe_function_type
private maybe_function_type ::= function_type | maybe_application
